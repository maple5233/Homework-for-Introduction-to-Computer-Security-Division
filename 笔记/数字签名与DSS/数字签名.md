[TOC]

# 数字签名

## 消息认证的缺陷

消息认证可以防范第三方的攻击，但是无法防止通信双方发起的攻击：

1. A可以伪造一条消息并声称来自B
2. 因为AB共享着消息认证码的密钥，所以A可以附上消息认证码
3. B可以否认，因为A有伪造的能力
4. 真相将不得而知

## 数字签名

### 特征

+ 能验证签名者，签名时间
+ 能认证签名内容未被修改
+ 由第三方仲裁

### 原理

数字签名应用了公钥密码领域使用的**单向函数**原理。单向函数指的是正向操作非常简单，而逆向操作非常困难的函数，比如大整数乘法。这种函数往往提供一种难解(NPC)或怀疑难解(NP)的数学问题。目前,公钥密码领域具备实用性的三个怀疑难解问题为：[质数分解](https://zh.wikipedia.org/wiki/%E8%B4%A8%E6%95%B0%E5%88%86%E8%A7%A3)，[离散对数](https://zh.wikipedia.org/wiki/%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0)和[椭圆曲线](https://zh.wikipedia.org/wiki/%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF)问题。

### 操作

+ 一言以蔽之，数字签名就是将公钥密码反过来使用。
  1. 签名者将讯息用私钥加密（这是一种反用，因为通常公钥密码中私钥用于解密）然后公布公钥
  2. 验证者使用公钥将加密讯息解密并比对消息（一般签名对象为消息的散列值。本节为了讲解方便，假设数字签名直接将消息而非散列值签名）
+ 可靠的公钥密码算法均能构建出可靠的数字签名
  1. Alice是签名者，假设她要对消息A进行签名。现在, Alice生成了其公私钥密码对，公布该公钥，然后将消息用私钥加密后发布。
  2. 现在，我们希望Alice的签名算法具有如下特性：
     + 确认消息在传输过程中没有丢位，没被篡改（完整性）
     + 确认消息的发送者是发布公钥的Alice（认证）
     + 确认Alice的确发布过该消息（不可否认性）
+ 普通的数字签名算法包括三种算法：
  - 密码生成算法
  - 标记算法
  - 验证算法

